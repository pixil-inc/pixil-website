---
import '@/styles/global.css';
import Header from '@/components/shared/Header.astro';
import Footer from '@/components/shared/Footer.astro';

interface Props {
  title?: string;
  description?: string;
}

const {
  title = 'Pixil Web Studio Inc.',
  description = 'Digital Excellence. Down to the last Pixil.',
} = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <meta name="description" content={description} />
    <title>{title}</title>

    <!-- Preload critical local font files -->
    <link href="/fonts/Inter-400.woff2" rel="preload" as="font" type="font/woff2" crossorigin />
    <link href="/fonts/Inter-500.woff2" rel="preload" as="font" type="font/woff2" crossorigin />

    <!-- Preconnect for Material Symbols (still from Google) -->
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin href="https://fonts.gstatic.com" rel="preconnect" />

    <!-- Load Material Symbols asynchronously -->
    <link
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
      rel="preload"
      as="style"
      onload="this.onload=null;this.rel='stylesheet'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
        rel="stylesheet"
      />
    </noscript>

    <!-- Simplified font loading detection for local fonts -->
    <script>
      // For local fonts, we can immediately apply font styles
      if ('fonts' in document) {
        document.fonts.load('400 1em Inter').then(() => {
          document.documentElement.classList.add('fonts-loaded');
        });
      }
    </script>
  </head>

  <body
    class="bg-oatmeal text-charcoal font-sans antialiased selection:bg-black selection:text-white"
  >
    <Header />
    <main class="pt-32 pb-20">
      <slot />
    </main>
    <Footer />

    <script>
      const observerOptions = {
        threshold: 0.1,
        rootMargin: '0px 0px -100px 0px',
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            if (entry.target.classList.contains('scroll-hidden')) {
              entry.target.classList.remove('scroll-hidden');
              entry.target.classList.add('scroll-visible');
            }
            if (entry.target.classList.contains('fade-up-hidden')) {
              entry.target.classList.remove('fade-up-hidden');
              entry.target.classList.add('fade-up-visible');
            }
          }
        });
      }, observerOptions);

      // Wait for DOM to be ready, then observe elements
      document.addEventListener('DOMContentLoaded', function () {
        const elementsToAnimate = document.querySelectorAll('.scroll-hidden, .fade-up-hidden');

        elementsToAnimate.forEach((el, index) => {
          observer.observe(el);
        });

        // Contact form toggle functionality
        const showFormBtn = document.getElementById('show-form-btn');
        const hideFormBtn = document.getElementById('hide-form-btn');
        const contactButtons = document.getElementById('contact-buttons');
        const contactForm = document.getElementById('contact-form');

        if (showFormBtn && contactButtons && contactForm) {
          showFormBtn.addEventListener('click', function (e) {
            e.preventDefault();
            contactButtons.style.display = 'none';
            contactForm.classList.remove('hidden');
            contactForm.style.opacity = '0';
            contactForm.style.transform = 'translateY(20px)';

            // Animate form in
            requestAnimationFrame(() => {
              contactForm.style.transition = 'all 0.5s cubic-bezier(0.16, 1, 0.3, 1)';
              contactForm.style.opacity = '1';
              contactForm.style.transform = 'translateY(0)';
            });
          });
        }

        if (hideFormBtn && contactButtons && contactForm) {
          hideFormBtn.addEventListener('click', function (e) {
            e.preventDefault();
            // Animate form out
            contactForm.style.transition = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
            contactForm.style.opacity = '0';
            contactForm.style.transform = 'translateY(-20px)';

            setTimeout(() => {
              contactForm.classList.add('hidden');
              contactButtons.style.display = 'flex';
            }, 300);
          });
        }

        // Header CTA visibility based on intro section
        const headerCta = document.getElementById('header-cta');
        const introSection = document.querySelector('section#intro');

        if (headerCta && introSection) {
          const headerObserver = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  // Intro section is in view - hide header CTA
                  headerCta.style.opacity = '0';
                  headerCta.style.transform = 'translateY(-10px)';
                  headerCta.style.pointerEvents = 'none';
                } else {
                  // Intro section is not in view - show header CTA
                  headerCta.style.opacity = '1';
                  headerCta.style.transform = 'translateY(0)';
                  headerCta.style.pointerEvents = 'auto';
                }
              });
            },
            {
              threshold: 0.1,
              rootMargin: '-50px 0px 0px 0px',
            }
          );

          // Initially hide the header CTA and add transition
          headerCta.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          headerCta.style.opacity = '0';
          headerCta.style.transform = 'translateY(-10px)';
          headerCta.style.pointerEvents = 'none';

          headerObserver.observe(introSection);
        }

        setTimeout(() => {
          elementsToAnimate.forEach((el) => {
            if (el.classList.contains('scroll-hidden')) {
              el.classList.remove('scroll-hidden');
              el.classList.add('scroll-visible');
            }
            if (el.classList.contains('fade-up-hidden')) {
              el.classList.remove('fade-up-hidden');
              el.classList.add('fade-up-visible');
            }
          });
        }, 3000);
      });

      // General smooth scroll utility for site-wide use
      function initSmoothScroll() {
        // Handle all elements with data-scroll-to attribute
        const scrollElements = document.querySelectorAll('[data-scroll-to]');

        scrollElements.forEach((element) => {
          element.addEventListener('click', (e) => {
            e.preventDefault();
            const targetId = element.getAttribute('data-scroll-to');

            if (targetId) {
              const targetSection = document.getElementById(targetId);

              if (targetSection) {
                targetSection.scrollIntoView({
                  behavior: 'smooth',
                  block: 'start',
                });
              }
            }
          });
        });
      }

      // Initialize smooth scroll
      initSmoothScroll();

      // Load reCAPTCHA v3 script dynamically
      function loadRecaptcha() {
        const siteKey = '6LdmlkcsAAAAAD-bCsMlXSbHrDMqll5nMDUZDGnV'; // Use your site key
        const script = document.createElement('script');
        script.src = `https://www.google.com/recaptcha/api.js?render=${siteKey}`;
        script.async = true;
        document.head.appendChild(script);
        return siteKey;
      }

      const recaptchaSiteKey = loadRecaptcha();

      // Pixil contact form interactions
      function initPixilForm() {
        const inputs = document.querySelectorAll('.pixil-input');
        const submitBtn = document.getElementById('submit-btn') as HTMLButtonElement;
        const submitText = document.querySelector('.submit-text') as HTMLElement;
        const loadingText = document.querySelector('.loading-text') as HTMLElement;
        const successMessage = document.getElementById('success-message') as HTMLElement;
        const form = document.querySelector('#contact-form form') as HTMLFormElement;

        // Active pixil effect on focus
        inputs.forEach((input) => {
          const indicator = input.parentElement?.querySelector('.pixil-indicator') as HTMLElement;

          input.addEventListener('focus', () => {
            if (indicator) {
              indicator.style.opacity = '1';
              indicator.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            }
          });

          input.addEventListener('blur', () => {
            if (indicator) {
              indicator.style.opacity = '0';
            }
          });
        });

        // Form submission handling
        if (form && submitBtn && submitText && loadingText) {
          form.addEventListener('submit', async (e) => {
            e.preventDefault();

            submitText.classList.add('hidden');
            loadingText.classList.remove('hidden');
            submitBtn.disabled = true;

            try {
              const token = await (window as any).grecaptcha.execute(recaptchaSiteKey, {
                action: 'contact_form',
              });

              setTimeout(() => {
                const buttonArea = submitBtn.parentElement;
                if (buttonArea && successMessage) {
                  buttonArea.classList.add('hidden');
                  successMessage.classList.remove('hidden');
                }
              }, 2000);
            } catch (error) {
              console.error('reCAPTCHA error:', error);
              submitText.classList.remove('hidden');
              loadingText.classList.add('hidden');
              submitBtn.disabled = false;
              alert('There was an issue with the security verification. Please try again.');
            }
          });
        }
      }

      initPixilForm();
    </script>
  </body>
</html>
